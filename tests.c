#include <inttypes.h>
#include <string.h>
#include <stdio.h>
#include <assert.h>
#include <stdlib.h>

#include <openssl/aes.h>

#include "common.h"
#include "etee.h"
#include "etee_efuncs.h"

#define VEC_SIZE_K 32
#define VEC_SIZE_IV 16
#define VEC_SIZE_BLK 48

typedef struct {
    uint8_t e1_iv[VEC_SIZE_IV];
    uint8_t e1_ct[VEC_SIZE_BLK];
    uint8_t e2_pt[VEC_SIZE_BLK];
    uint8_t e3_pt[VEC_SIZE_BLK];
    uint8_t e4e_ct[VEC_SIZE_BLK];
    uint8_t e4d_pt[VEC_SIZE_BLK];
    uint8_t e5_ct[VEC_SIZE_BLK];
    uint8_t e5_ct2[VEC_SIZE_BLK];
    uint8_t e6_ct[VEC_SIZE_BLK];
    uint8_t e6_ct2[VEC_SIZE_BLK];
    uint8_t encdec_e_ct[VEC_SIZE_BLK];
    uint8_t encdec_d_pt[VEC_SIZE_BLK];
} EteePrimTestVec;

// EteeKeystore g_stEteeKeystore;

// Some random data to base tests on
static uint8_t g_abTestKey[VEC_SIZE_K] = {
    0xad,0xe6,0x89,0xb5,0x19,0xae,0x02,0x68,0x82,0x1f,0xd1,0x33,0x91,0x28,0x2d,0x1c,
    0x3c,0xb7,0xf1,0x23,0x84,0x20,0xb8,0xdc,0x83,0xd9,0x99,0x16,0x88,0xb5,0xb7,0x4a};
static uint8_t g_abTestIv[VEC_SIZE_IV] = {
    0x8e,0x6e,0xaf,0x41,0x6f,0xbf,0x2f,0xac,0x4d,0x04,0x67,0x60,0x5b,0x3b,0x29,0xe9};
static uint8_t g_abTestData[VEC_SIZE_BLK] = {
    0x97,0x12,0x29,0x7d,0x72,0x18,0xb7,0xbf,0x33,0x68,0xe0,0xf0,0x00,0x64,0xe5,0x6f, 
    0xea,0x4c,0xa8,0x56,0xf1,0x39,0xe6,0x82,0x1d,0x58,0x4c,0x7f,0x24,0x9f,0x44,0x26,
    0x75,0x04,0x2e,0xf0,0xe2,0x15,0x24,0x4e,0x53,0xc3,0xcf,0xc8,0x2e,0x8f,0xf6,0xe7};


void init_test_keystore(EteeKeystore *lpKeystore, enum tetra_etee_algid eAlgId) {

    // uint16_t eAlgId = ETEE_ALG_AES128;

    EteeKeystore stKeystore = {
        .stKek = {
            .dwKeyId = 0x1337,
            .eAlgId = eAlgId,
            .wKeyLenBits = get_alg_properties(eAlgId)->bKeySize * 8,
            .abKey = {0xad,0xe6,0x89,0xb5,0x19,0xae,0x02,0x68,0x82,0x1f,0xd1,0x33,0x91,0x28,0x2d,0x1c},            
            .bKeyIsLoaded = 1,
        }, 
        .stSek = {
            .dwKeyId = 0x1338,
            .eAlgId = eAlgId,
            .wKeyLenBits = get_alg_properties(eAlgId)->bKeySize * 8,
            .abKey = {0xad,0xe6,0x89,0xb5,0x19,0xae,0x02,0x68,0x82,0x1f,0xd1,0x33,0x91,0x28,0x2d,0x1c},            
            .bKeyIsLoaded = 1,
        }, 
        .astTeks = {
            {
                .dwKeyId = 0x100,
                .eAlgId = eAlgId,
                .wKeyLenBits = get_alg_properties(eAlgId)->bKeySize * 8,
                .abKey = {0xad,0xe6,0x89,0xb5,0x19,0xae,0x02,0x68,0x82,0x1f,0xd1,0x33,0x91,0x28,0x2d,0x1c},            
                .bKeyIsLoaded = 1,
            }, {
                .dwKeyId = 0x101,
                .eAlgId = eAlgId,
                .wKeyLenBits = get_alg_properties(eAlgId)->bKeySize * 8,
                .abKey = {0xad,0xe6,0x89,0xb5,0x19,0xae,0x02,0x68,0x82,0x1f,0xd1,0x33,0x91,0x28,0x2d,0x1c},            
                .bKeyIsLoaded = 1,
            }, {
                .dwKeyId = 0x102,
                .eAlgId = eAlgId,
                .wKeyLenBits = get_alg_properties(eAlgId)->bKeySize * 8,
                .abKey = {0xad,0xe6,0x89,0xb5,0x19,0xae,0x02,0x68,0x82,0x1f,0xd1,0x33,0x91,0x28,0x2d,0x1c},            
                .bKeyIsLoaded = 1,
            }
        }
    };

    // Copy to dest
    memcpy(lpKeystore, &stKeystore, sizeof(EteeKeystore));
}
    
static void reset_vecs(uint8_t *base_key, uint8_t *base_iv, uint8_t *base_blocks, uint8_t *k, uint8_t *iv, uint8_t *pt, uint8_t *ct, uint8_t *ct2) {
    memcpy(k, base_key, VEC_SIZE_K);
    memcpy(iv, base_iv, VEC_SIZE_IV);
    memcpy(pt, base_blocks, VEC_SIZE_BLK);
    memcpy(ct, base_blocks, VEC_SIZE_BLK);
    memset(ct2, 0, VEC_SIZE_BLK);
}

static void print_vecs(uint8_t *k, uint8_t *iv, uint8_t *pt, uint8_t *ct, uint8_t *ct2) {
    printf("  k:   %s\n" , hexdump(k, VEC_SIZE_K)); 
    printf("  iv:  %s\n" , hexdump(iv, VEC_SIZE_IV)); 
    printf("  pt:  %s\n" , hexdump(pt, VEC_SIZE_BLK)); 
    printf("  ct:  %s\n" , hexdump(ct, VEC_SIZE_BLK));
    printf("  ct2: %s\n" , hexdump(ct2, VEC_SIZE_BLK)); 
}

void test_e_prims() {
    
    // Test E-functions
    uint8_t k[VEC_SIZE_K]; 
    uint8_t iv[VEC_SIZE_IV]; 
    uint8_t ct[VEC_SIZE_BLK]; 
    uint8_t pt[VEC_SIZE_BLK]; 
    uint8_t ct2[VEC_SIZE_BLK];
    uint8_t abTestKeyBak[VEC_SIZE_K]; /* Because destroyed by AES56 bench */

    /* TODO FIXME include IDEA in tests */
    uint16_t awAlgs[] = {ETEE_ALG_AES128, ETEE_ALG_AES56, ETEE_ALG_AES256};
    int dwNumAlgs = sizeof(awAlgs) / sizeof(awAlgs[0]);

    EteePrimTestVec astVecs[3] = {
        { // AES128
            .e1_iv =       {0x03,0x24,0xe0,0x2b,0x13,0x93,0x10,0x75,0x4d,0x04,0x67,0x60,0x5b,0x3b,0x29,0xe9},
            .e1_ct =       {0x8c,0xc7,0x03,0xa8,0xac,0x73,0x59,0x2d,0xcb,0x7d,0x2c,0xa8,0x9c,0xe1,0x8f,0xb8,0xed,0x79,0x94,0x41,0x15,0x1b,0xeb,0x85,0x6a,0xf2,0x08,0xaa,0xb9,0xb7,0x66,0x3b,0x2c,0xab,0x86,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
            .e2_pt =       {0x07,0x6d,0x1d,0xa2,0x97,0xd9,0x15,0x2f,0x9d,0x7b,0xf6,0xf3,0x26,0x74,0x2b,0xbc,0xec,0xa0,0x24,0x61,0xc5,0x9e,0xd2,0x90,0xf6,0x82,0xca,0x16,0x12,0xd9,0x90,0x3c,0x2e,0x0d,0x43,0xe0,0x07,0xcf,0xb4,0x1b,0x6b,0x99,0x6f,0x00,0xe0,0x12,0x47,0xc1},
            .e3_pt =       {0x67,0x11,0x45,0xe1,0x31,0x5c,0xe8,0x0c,0x8e,0x6d,0x17,0xf5,0x31,0xce,0x82,0x4a,0xea,0x4c,0xa8,0x56,0xf1,0x39,0xe6,0x82,0x1d,0x58,0x4c,0x7f,0x24,0x9f,0x44,0x26,0x75,0x04,0x2e,0xf0,0xe2,0x15,0x24,0x4e,0x53,0xc3,0xcf,0xc8,0x2e,0x8f,0xf6,0xe7},
            .e4e_ct =      {0x3f,0x51,0x46,0xb3,0xc8,0x19,0x13,0x63,0xf8,0xf4,0xd3,0x02,0xc3,0x45,0xa7,0x98,0x48,0xc2,0x30,0x07,0xb1,0xf7,0xf2,0xf2,0xc7,0xb1,0xb2,0x09,0xe6,0xbd,0x75,0x53,0xa1,0x19,0x38,0xc2,0x86,0x3a,0x3b,0x2a,0x2d,0x82,0x8d,0x9a,0xef,0x39,0x52,0x99},
            .e4d_pt =      {0x89,0x03,0xb2,0xe3,0xf8,0x66,0x3a,0x83,0xd0,0x7f,0x91,0x93,0x7d,0x4f,0x02,0x55,0xec,0xa0,0x24,0x61,0xc5,0x9e,0xd2,0x90,0xf6,0x82,0xca,0x16,0x12,0xd9,0x90,0x3c,0x2e,0x0d,0x43,0xe0,0x07,0xcf,0xb4,0x1b,0x6b,0x99,0x6f,0x00,0xe0,0x12,0x47,0xc1},
            .e5_ct =       {0x67,0x11,0x45,0xe1,0x31,0x5c,0xe8,0x0c,0x8e,0x6d,0x17,0xf5,0x31,0xce,0x82,0x4a,0xd3,0x7f,0x0f,0x2f,0xaa,0x56,0x48,0x03,0x42,0x13,0x0a,0x1b,0x62,0x9b,0xb0,0xea,0xaa,0x98,0xbb,0x67,0xc4,0x6a,0xf0,0x06,0x7a,0xc8,0xfc,0x10,0x97,0x42,0x53,0x82},
            .e5_ct2 =      {0xa1,0xbb,0xd4,0x76,0x5e,0xce,0xe5,0xcd,0x1c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
            .e6_ct =       {0xd4,0x2a,0x38,0xf7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
            .e6_ct2 =      {0x46,0x3e,0x94,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
            .encdec_e_ct = {0x67,0x11,0x45,0xe1,0x31,0x5c,0xe8,0x0c,0x8e,0x6d,0x17,0xf5,0x31,0xce,0x82,0x4a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
            .encdec_d_pt = {0x07,0x6d,0x1d,0xa2,0x97,0xd9,0x15,0x2f,0x9d,0x7b,0xf6,0xf3,0x26,0x74,0x2b,0xbc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
        }, { // AES56
            .e1_iv =       {0x7a,0x56,0x08,0xf1,0xc9,0x95,0xbe,0x60,0x4d,0x04,0x67,0x60,0x5b,0x3b,0x29,0xe9},
            .e1_ct =       {0xa7,0xa2,0xe0,0xd6,0x71,0xf7,0x48,0x73,0x75,0xe5,0x6b,0x8a,0x48,0x81,0x0b,0x70,0xba,0x55,0x03,0x40,0xd4,0x90,0x14,0xe3,0xdd,0xd6,0x3d,0xd7,0x2e,0x80,0xc6,0xcb,0x6f,0xa2,0x2b,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
            .e2_pt =       {0xc7,0x46,0x81,0xac,0xa1,0xe7,0x7f,0xab,0xb7,0xc5,0x00,0x22,0x5c,0x53,0xc4,0x65,0x19,0xb2,0x60,0xfc,0xfb,0x3b,0x99,0xfa,0xa7,0x18,0x1d,0xc9,0x1a,0x5c,0xdb,0xf3,0xea,0xf7,0x53,0x85,0x76,0x8c,0x23,0x38,0x0a,0xa6,0xae,0x82,0x42,0x9b,0xe2,0x4a},
            .e3_pt =       {0x13,0xa0,0xbe,0xd6,0x79,0x02,0x49,0x46,0x67,0xd5,0xd8,0x66,0x74,0xad,0xef,0x4d,0xea,0x4c,0xa8,0x56,0xf1,0x39,0xe6,0x82,0x1d,0x58,0x4c,0x7f,0x24,0x9f,0x44,0x26,0x75,0x04,0x2e,0xf0,0xe2,0x15,0x24,0x4e,0x53,0xc3,0xcf,0xc8,0x2e,0x8f,0xf6,0xe7},
            .e4e_ct =      {0x58,0x73,0xde,0x0d,0x23,0x54,0x54,0xc6,0x4b,0x49,0x3a,0xb8,0xdc,0xed,0xb9,0x07,0x1d,0x46,0xdb,0x6f,0xeb,0xda,0x7f,0x63,0x6e,0xa8,0x61,0xa3,0xf0,0x20,0x8c,0x93,0x46,0x2c,0xff,0x7b,0x5a,0x75,0xa1,0x5b,0x20,0x35,0xa9,0xf8,0x45,0x7a,0x89,0x79},
            .e4d_pt =      {0x49,0x28,0x2e,0xed,0xce,0x58,0x50,0x07,0xfa,0xc1,0x67,0x42,0x07,0x68,0xed,0x8c,0x19,0xb2,0x60,0xfc,0xfb,0x3b,0x99,0xfa,0xa7,0x18,0x1d,0xc9,0x1a,0x5c,0xdb,0xf3,0xea,0xf7,0x53,0x85,0x76,0x8c,0x23,0x38,0x0a,0xa6,0xae,0x82,0x42,0x9b,0xe2,0x4a},
            .e5_ct =       {0x13,0xa0,0xbe,0xd6,0x79,0x02,0x49,0x46,0x67,0xd5,0xd8,0x66,0x74,0xad,0xef,0x4d,0x28,0x35,0x77,0xcc,0x05,0x05,0xd1,0x39,0xd3,0xbd,0x7b,0xa3,0x5a,0x7b,0x45,0x6a,0xca,0x6c,0x4f,0x24,0xca,0xd3,0x3b,0xe4,0xd1,0xf8,0xf9,0x3e,0xbd,0x09,0xcf,0x7c},
            .e5_ct2 =      {0x0c,0x68,0x53,0x90,0x15,0x5c,0xfd,0x84,0xdc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
            .e6_ct =       {0x9c,0xcf,0x39,0xa3,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
            .e6_ct2 =      {0xff,0x99,0xd0,0x88,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
            .encdec_e_ct = {0x13,0xa0,0xbe,0xd6,0x79,0x02,0x49,0x46,0x67,0xd5,0xd8,0x66,0x74,0xad,0xef,0x4d,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
            .encdec_d_pt = {0xc7,0x46,0x81,0xac,0xa1,0xe7,0x7f,0xab,0xb7,0xc5,0x00,0x22,0x5c,0x53,0xc4,0x65,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
        }, { // AES256
            .e1_iv =       {0xd5,0x4c,0x60,0x36,0x7c,0x12,0xca,0x6f,0x4d,0x04,0x67,0x60,0x5b,0x3b,0x29,0xe9},
            .e1_ct =       {0x7a,0x8e,0x57,0x9d,0xbc,0x3f,0x35,0xc7,0xf6,0x9c,0x9d,0xf2,0x95,0xaf,0x3c,0xbe,0x1b,0xa6,0xf3,0x3b,0x0d,0x45,0x67,0x21,0x9f,0xe5,0x9c,0x90,0x61,0x0e,0xdd,0x88,0xaf,0x34,0x67,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
            .e2_pt =       {0x61,0xba,0x69,0xdc,0x48,0xa9,0xc5,0x93,0x6e,0x2b,0xbe,0x21,0xb1,0x97,0xba,0xff,0xe9,0xdb,0xdb,0xcf,0xd8,0x1a,0x9e,0xd1,0x4a,0xf8,0xd2,0x44,0xb8,0x54,0xe7,0x8a,0xb3,0x3e,0xa2,0xa2,0xb5,0x24,0x9e,0x2e,0x0f,0x19,0x1f,0x91,0x4e,0xc2,0x02,0x9a},
            .e3_pt =       {0xda,0x26,0x19,0xf8,0x1b,0xd4,0x64,0x5e,0x71,0x5f,0xdd,0x66,0x49,0x65,0xd5,0xae,0xea,0x4c,0xa8,0x56,0xf1,0x39,0xe6,0x82,0x1d,0x58,0x4c,0x7f,0x24,0x9f,0x44,0x26,0x75,0x04,0x2e,0xf0,0xe2,0x15,0x24,0x4e,0x53,0xc3,0xcf,0xc8,0x2e,0x8f,0xf6,0xe7},
            .e4e_ct =      {0x64,0x99,0x8e,0x11,0xb9,0x8d,0xe9,0x99,0x2a,0xd8,0x2d,0x3c,0xca,0xbc,0xbc,0xc7,0xcf,0xd3,0x77,0x50,0x4e,0xec,0xb3,0xe5,0x3d,0x47,0x05,0x7f,0x99,0xca,0x8e,0x86,0x94,0x03,0xf9,0x27,0x73,0x5c,0xb3,0xc0,0x03,0x77,0x8f,0x46,0x6a,0x80,0x8b,0x76},
            .e4d_pt =      {0xef,0xd4,0xc6,0x9d,0x27,0x16,0xea,0x3f,0x23,0x2f,0xd9,0x41,0xea,0xac,0x93,0x16,0xe9,0xdb,0xdb,0xcf,0xd8,0x1a,0x9e,0xd1,0x4a,0xf8,0xd2,0x44,0xb8,0x54,0xe7,0x8a,0xb3,0x3e,0xa2,0xa2,0xb5,0x24,0x9e,0x2e,0x0f,0x19,0x1f,0x91,0x4e,0xc2,0x02,0x9a},
            .e5_ct =       {0xda,0x26,0x19,0xf8,0x1b,0xd4,0x64,0x5e,0x71,0x5f,0xdd,0x66,0x49,0x65,0xd5,0xae,0x2e,0xc7,0x8b,0x2b,0x11,0x46,0x71,0x5c,0x7b,0xef,0x2d,0x62,0x00,0xed,0x4f,0x40,0x5c,0x98,0xdd,0xf4,0xb0,0x5d,0xce,0x2f,0x7c,0xf5,0x16,0xed,0x2f,0x5d,0xdf,0x2f},
            .e5_ct2 =      {0xb6,0x61,0x1d,0x07,0x41,0x3e,0xd3,0xcf,0x29,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
            .e6_ct =       {0x93,0xf0,0x6f,0xb7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
            .e6_ct2 =      {0x9c,0xfb,0xc5,0xd9,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
            .encdec_e_ct = {0xda,0x26,0x19,0xf8,0x1b,0xd4,0x64,0x5e,0x71,0x5f,0xdd,0x66,0x49,0x65,0xd5,0xae,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
            .encdec_d_pt = {0x61,0xba,0x69,0xdc,0x48,0xa9,0xc5,0x93,0x6e,0x2b,0xbe,0x21,0xb1,0x97,0xba,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
        }
    };

    for (int i = 0; i < dwNumAlgs; i++) {
        uint16_t eAlgId = awAlgs[i];
        const EteeAlg *lpAlgProps = get_alg_properties(eAlgId);

        printf("-- RUNNING TESTS FOR ALG %s (id 0x%X) --\n", lpAlgProps->szAlgName, eAlgId);

        if (eAlgId == ETEE_ALG_AES56) {
            printf("\nTesting etee_process_key_aes56:\n");;
            reset_vecs(g_abTestKey, g_abTestIv, g_abTestData, k, iv, pt, ct, ct2);
            etee_process_key(k, eAlgId);
            printf("SETTING NEW K: %s\n", hexdump(k, VEC_SIZE_K));
            memcpy(abTestKeyBak, g_abTestKey, VEC_SIZE_K);
            memcpy(g_abTestKey, k, VEC_SIZE_K);
        }

        printf("Testing E1:\n");
        reset_vecs(g_abTestKey, g_abTestIv, g_abTestData, k, iv, pt, ct, ct2);
        memset(ct, 0, VEC_SIZE_BLK);
        etee_e1(k, iv, ct, eAlgId); 
        print_vecs(k, iv, pt, ct, ct2);
        assert(memcmp(ct, astVecs[i].e1_ct, sizeof(astVecs[i].e1_ct)) == 0);
        assert(memcmp(iv, astVecs[i].e1_iv, sizeof(astVecs[i].e1_iv)) == 0);
        
        printf("\nTesting E2 and inverse:\n");
        reset_vecs(g_abTestKey, g_abTestIv, g_abTestData, k, iv, pt, ct, ct2);
        memset(pt, 0, VEC_SIZE_BLK);
        etee_e2(k, ct, pt, 3, eAlgId);
        print_vecs(k, iv, pt, ct, ct2);
        assert(memcmp(pt, astVecs[i].e2_pt, sizeof(astVecs[i].e2_pt)) == 0);

        memset(ct, 0, VEC_SIZE_BLK);
        etee_e2_inv(k, pt, ct, 3, eAlgId);
        print_vecs(k, iv, pt, ct, ct2);
        assert(memcmp(ct, g_abTestData, VEC_SIZE_BLK) == 0);

        printf("\nTesting E3:\n");
        reset_vecs(g_abTestKey, g_abTestIv, g_abTestData, k, iv, pt, ct, ct2);
        etee_e3(k, pt, eAlgId);
        print_vecs(k, iv, pt, ct, ct2);
        assert(memcmp(pt, astVecs[i].e3_pt, sizeof(astVecs[i].e3_pt)) == 0);

        printf("\nTesting E4 encrypt:\n");
        reset_vecs(g_abTestKey, g_abTestIv, g_abTestData, k, iv, pt, ct, ct2);
        etee_e4(k, iv, pt, 3, 1, eAlgId);
        print_vecs(k, iv, pt, ct, ct2);
        assert(memcmp(pt, astVecs[i].e4e_ct, sizeof(astVecs[i].e4e_ct)) == 0);

        printf("\nTesting E4:\n");
        reset_vecs(g_abTestKey, g_abTestIv, g_abTestData, k, iv, pt, ct, ct2);
        etee_e4(k, iv, ct, 3, 0, eAlgId);
        print_vecs(k, iv, pt, ct, ct2);
        assert(memcmp(ct, astVecs[i].e4d_pt, sizeof(astVecs[i].e4d_pt)) == 0);

        printf("\nTesting E5:\n");
        reset_vecs(g_abTestKey, g_abTestIv, g_abTestData, k, iv, pt, ct, ct2);
        memset(ct, 0, VEC_SIZE_BLK);
        memset(ct2, 0, VEC_SIZE_BLK);
        etee_e5(k, pt, ct, eAlgId, 3, ct2);
        print_vecs(k, iv, pt, ct, ct2);
        assert(memcmp(ct, astVecs[i].e5_ct, sizeof(astVecs[i].e5_ct)) == 0);
        assert(memcmp(ct2, astVecs[i].e5_ct2, sizeof(astVecs[i].e5_ct2)) == 0);

        printf("\nTesting E6:\n");
        reset_vecs(g_abTestKey, g_abTestIv, g_abTestData, k, iv, pt, ct, ct2);
        memset(ct, 0, VEC_SIZE_BLK);
        memset(ct2, 0, VEC_SIZE_BLK);
        print_vecs(k, iv, pt, ct, ct2);
        etee_e6(k, pt, 3, ct, ct2, eAlgId);
        assert(memcmp(ct, astVecs[i].e6_ct, sizeof(astVecs[i].e6_ct)) == 0);
        assert(memcmp(ct2, astVecs[i].e6_ct2, sizeof(astVecs[i].e6_ct2)) == 0);

        printf("\nTesting enc_dec_blk encrypt:\n");
        reset_vecs(g_abTestKey, g_abTestIv, g_abTestData, k, iv, pt, ct, ct2);
        memset(ct, 0, VEC_SIZE_BLK);
        etee_crypt_blk(pt, k, ct, 1, eAlgId);
        print_vecs(k, iv, pt, ct, ct2);
        assert(memcmp(ct, astVecs[i].encdec_e_ct, sizeof(astVecs[i].encdec_e_ct)) == 0);

        printf("\nTesting enc_dec_blk decrypt:\n");
        reset_vecs(g_abTestKey, g_abTestIv, g_abTestData, k, iv, pt, ct, ct2);
        memset(pt, 0, VEC_SIZE_BLK);
        etee_crypt_blk(ct, k, pt, 0, eAlgId);
        print_vecs(k, iv, pt, ct, ct2);
        assert(memcmp(pt, astVecs[i].encdec_d_pt, sizeof(astVecs[i].encdec_d_pt)) == 0);

        if (eAlgId == ETEE_ALG_AES56) {
            // Restore original base key for next tests
            memcpy(g_abTestKey, abTestKeyBak, VEC_SIZE_K);
        }
    }
}

void test_syncframe() {
    // Define key
    uint16_t eAlgId = ETEE_ALG_AES128;
	uint32_t dwKeyId = 0x1337;
	uint8_t base_key[16] = {0xad,0xe6,0x89,0xb5,0x19,0xae,0x02,0x68,0x82,0x1f,0xd1,0x33,0x91,0x28,0x2d,0x1c};
    uint8_t abExpectedResult[] = {0x10,0x89,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x00,0x4c,0xdc,0xdd,0x57,0x40};

    // Setup Tek
    const EteeAlg *lpstAlg = get_alg_properties(eAlgId);
    EteeKey stKey;
    memset(&stKey, 0, sizeof(EteeKey));
	stKey.dwKeyId = dwKeyId;
    stKey.eAlgId = eAlgId;
	// stKey.bUnk6 = 1; // Unknown field in EteeReversedKey struct
    stKey.wKeyLenBits = lpstAlg->bKeySize * 8;
    memcpy(stKey.abKey, base_key, 16);
    stKey.bKeyIsLoaded = 1;

    uint8_t abSf[16];
    uint8_t abIv[8], abIvExtracted[8];
    for (int i = 0; i < 8; i++) {
        abIv[i] = i + 0x10;
    }
    // memcpy(&g_stEteTestKey, &stKey, sizeof(EteeKey));

    etee_generate_syncframe(&stKey, abIv, abSf);
    
    printf("GenerateSyncFrame: got sync frame: %s\n", hexdump(abSf, 16));
    printf("             expect                %s\n", hexdump(abExpectedResult, 16));
    assert(memcmp(abExpectedResult, abSf, 16) == 0);

    bool ok = etee_unpack_syncframe(&stKey, 1, abSf, abIvExtracted);
    if (ok) {
        printf("UnpackSyncFrame: Got AlgID 0x%X KeyID 0x%X, iv: %s\n", stKey.eAlgId, stKey.dwKeyId, hexdump(abIv, 8));
    }    
    assert(ok);
    assert(memcmp(abIv, abIvExtracted, 8) == 0);

    abSf[6] += 1; // Tamper with IV
    ok = etee_unpack_syncframe(&stKey, 1, abSf, abIv);
    if (!ok) {
        printf("UnpackSyncFrame: Corrupted frame correctly discarded\n");
    }    
    assert(!ok);
}


void test_tek_seal_unseal() {

    // Checks the key seal/unseal feature
    // Reports success if sealed data is retrieved back successfully from unseal

    printf("\nTesting TEK seal and unseal:\n");

    // Set KEK in keystore
    EteeKeystore stKeystore;
    init_test_keystore(&stKeystore, ETEE_ALG_AES128);

    uint8_t abSealed[48] = {0};
    uint8_t abUnsealed_computed[48] = {0};

    bool ok;
    EteeKey *lpTek = &stKeystore.astTeks[0];
    ok = etee_seal_tek(&stKeystore.stKek, lpTek, abSealed);
    if (ok) {
        printf("Unsealed TEK: %s\n", hexdump(lpTek->abKey, sizeof(lpTek->abKey)));
        printf("Sealed buf:   %s\n", hexdump(abSealed, sizeof(abSealed)));
    } else {
        printf("Failed to seal TEK\n");
        return;
    }
    assert(ok);

    EteeKey stUnsealedTek = {
        .dwKeyId = lpTek->dwKeyId,
        .eAlgId = lpTek->eAlgId
    };
    ok = etee_unseal_tek(&stKeystore.stKek, &stUnsealedTek, abSealed, abUnsealed_computed);
    if (ok) {
        printf("Unsealed buf: %s\n", hexdump(abUnsealed_computed, sizeof(abUnsealed_computed)));
        printf("Unsealed TEK: %s\n", hexdump(stUnsealedTek.abKey, sizeof(stUnsealedTek.abKey)));
        assert(memcmp(stUnsealedTek.abKey, lpTek->abKey, sizeof(stUnsealedTek.abKey)) == 0);
    } else {
        printf("Failed to unseal TEK\n");
        return;
    }
    assert(ok);
    assert(!memcmp(stUnsealedTek.abKey, lpTek->abKey, (stUnsealedTek.wKeyLenBits + 7)/8));
}

void test_kmm_seal_unseal() {

    EteeKeystore stKeystore;
    init_test_keystore(&stKeystore, ETEE_ALG_AES128);

    EteeKmmReq stCtx = {
        .bEncrypt = true,
        .wKekAlgId = ETEE_ALG_AES128,
        .dwKekId = 0x1337, // Our KEK in the keystore
        .abIv = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15},
        .dwBufLen = 16,
        .abPtBuf = {0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f},
    };

    bool bErr = etee_kmm_req(&stKeystore, &stCtx);
    printf("Got: %d %s\n", bErr, hexdump(stCtx.abCtBuf, 16));

    stCtx.bEncrypt = false;
    memset(stCtx.abPtBuf, 0, sizeof(stCtx.abPtBuf));

    etee_kmm_req(&stKeystore, &stCtx);
    printf("Got: %d %s\n", bErr, hexdump(stCtx.abPtBuf, 16));
}


void test_sds_encr_decr() {
    
    EteeKey stKey = {
        .dwKeyId = 0x5252,
        .eAlgId = ETEE_ALG_AES128,
        .wKeyLenBits = get_alg_properties(ETEE_ALG_AES128)->bKeySize * 8,
        .abKey = {0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42},            
        .bKeyIsLoaded = 1,
    };

    EteeSdsCtx stDecCtx = {
        .lpstKey = &stKey,
        .abSenderIssi = {0x00,0x27,0x11}, // type1 only
        .dwNonce = 0x123458, // type2 only
    };

    // Vectors from radio, one for each type
    uint32_t adwSdsLens[3] = {22, 22, 17};
    uint8_t abEncryptedSdsOut[22];
    uint8_t abEncryptedSds[3][22] = {
        {0x08,0x90,0x52,0x52,0xB9,0x1F,0xA2,0x7A,0x5B,0xB9,0x12,0x9D,0xD2,0xF3,0x4B,0x73,0x35,0x2A,0x93,0x5F,0x50,0x28},
        {0x48,0x90,0x52,0x52,0x02,0xC5,0x33,0x6F,0x11,0x02,0x10,0xBD,0x86,0x61,0x16,0xB7,0x4C,0x48,0x32,0x39,0x55,0x92},
        {0x88,0x90,0x52,0x52,0x5E,0xC0,0x1D,0x10,0xC3,0x2E,0xD1,0x2B,0xC6,0xA0,0xC5,0x4C,0x37}
    };
    bool success;

    for (int type = 0; type < 3; type++) {

        printf("\n--- TYPE%d DEC ------------------------------: \n", type);

        memset(abEncryptedSdsOut, 0, sizeof(abEncryptedSdsOut));
        uint32_t dwLenBits = adwSdsLens[type]*8;        
        uint32_t dwLenBytes = (dwLenBits + 7) / 8;
        uint32_t dwPivLen = (stDecCtx.bSvType == 2 ? 4 : 9);
        
        // Compute decryption
        success = etee_sds_decrypt(abEncryptedSds[type], dwLenBits, &stDecCtx);

        uint32_t dwPtLenBits = stDecCtx.dwPtLenBits;
        uint32_t dwPtLenBytes = (dwPtLenBits + 7) / 8;

        printf("Inputs: \n");
        printf("    sds_ct:   %s\n", hexdump(stDecCtx.abSdsCt, dwPtLenBytes));
        if (stDecCtx.bSvType == 1) {
            printf("    Sender ISSI:    %d\n", (stDecCtx.abSenderIssi[0] << 16) | (stDecCtx.abSenderIssi[1] << 8) | stDecCtx.abSenderIssi[2]);
        }
        printf("\nExtracted:\n");
        printf("    svtype %d algid %x keyid %x\n", stDecCtx.bSvType, stDecCtx.lpstKey->eAlgId, stDecCtx.lpstKey->dwKeyId);
        printf("    ptlen: %d bits (%d bytes)\n", dwPtLenBits, dwPtLenBytes);
        printf("    Piv:   %s\n", hexdump(stDecCtx.abSdsPiv, dwPivLen));
        printf("    Mac1:  %s\n", hexdump(stDecCtx.abMac1_extracted, 4));
        printf("    ct:    %s\n", hexdump(stDecCtx.abSdsCt, dwPtLenBytes));
        printf("    ccsum: %s\n", hexdump(stDecCtx.abCcsum, 4));
        printf("\nComputed:\n");
        printf("    iv:     %s\n", hexdump(stDecCtx.abFullIv, 16));
        printf("    Ks:     %s\n", hexdump(stDecCtx.abSdsKs, dwPtLenBytes));
        printf("    Pt:     %s\n", hexdump(stDecCtx.abPt, dwPtLenBytes));

        printf("\nMAC/CCSUM computation:\n");
        printf("    MAC1:   %s\n", hexdump(stDecCtx.abMac1, 4)); 
        printf("    MAC2:   %s\n", hexdump(stDecCtx.abMac2, 4));
        printf("    CCSUM   %s\n", hexdump(stDecCtx.abCcsum, 4));

        // This check is not implemented in the TEE but seems obvious
        if (memcmp(stDecCtx.abMac1_extracted, stDecCtx.abMac1, 4)) {
            printf("[-] MAC VALIDATION FAILED!!\n");
            assert(0);
        } else {
            printf("[+] MAC validation: SUCCESS\n");
        }
        assert(success);

        // Test encryption
        printf("\n--- TYPE%d ENC ------------------------------: \n", type);

        // Create fresh context, copy over essential info
        EteeSdsCtx stEncCtx = {
            .bSvType = stDecCtx.bSvType,
            .lpstKey = stDecCtx.lpstKey,
            .dwPtLenBits = stDecCtx.dwPtLenBits,
            .dwNonce = stDecCtx.dwNonce,
        };
        memcpy(stEncCtx.abPt, stDecCtx.abPt, sizeof(stDecCtx.abPt));
        memcpy(stEncCtx.abSdsPiv, stDecCtx.abSdsPiv, sizeof(stDecCtx.abSdsPiv));
        memcpy(stEncCtx.abSenderIssi, stDecCtx.abSenderIssi, sizeof(stDecCtx.abSenderIssi)); // Only for type 1

        success = etee_sds_encrypt(abEncryptedSdsOut, &stEncCtx);

        printf("Inputs:\n");
        printf("    SdsPt:  %s\n", hexdump(stEncCtx.abPt, dwPtLenBytes));
        printf("    svtype: %d algid %x keyid %x\n", stEncCtx.bSvType, stEncCtx.lpstKey->eAlgId, stEncCtx.lpstKey->dwKeyId);
        if (stEncCtx.bSvType == 1) {
            printf("    ISSI:   %d\n", (stEncCtx.abSenderIssi[0] << 16) | (stEncCtx.abSenderIssi[1] << 8) | stEncCtx.abSenderIssi[2]);
        }
        printf("\nComputed:\n");
        printf("    iv:     %s\n", hexdump(stEncCtx.abFullIv, 16));
        printf("\nResults:\n");
        printf("    SdsCt:  %s\n", hexdump(stEncCtx.abSdsCt, dwPtLenBytes));
        printf("    MAC1:   %s\n", hexdump(stEncCtx.abMac1, 4)); 
        printf("    MAC2:   %s\n", hexdump(stEncCtx.abMac2, 4));
        printf("    CCSUM:  %s\n", hexdump(stEncCtx.abCcsum, 4));
        printf("    Packed: %s\n", hexdump(abEncryptedSdsOut, dwLenBytes));

        assert(success);
        assert(!memcmp(abEncryptedSds[type], abEncryptedSdsOut, dwLenBytes));
        assert(!memcmp(stEncCtx.abCcsum, stEncCtx.abCcsum, 4));
    }
}

int main() {

    test_e_prims();
    test_syncframe();
    test_tek_seal_unseal();
    test_kmm_seal_unseal();
    test_sds_encr_decr();

    printf("[+] All checks good\n");
    return 0;
}

